// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See LICENSE.txt in the project root for
// license information.

#pragma once

#include <iomanip>
#include <iostream>
#include <qdk/chemistry/utils/logger.hpp>
#include <sstream>

#include "arnoldi.h"

namespace qdk::chemistry::scf {
namespace detail {

/**
 * @brief Default (identity) shift operator
 *
 * Z = ALPHA * X + BETA * Y
 *
 * @param[in] N Problem dimension
 * @param[in] K Number of vectors to shift
 * @param[in] ALPHA X-laden scaling factor
 * @param[in] X Input block vector
 * @param[in] LDX Leading dimension of X
 * @param[in] BETA Y-laden scaling factor
 * @param[in] Y Input block vector
 * @param[in] LDY Leading dimension of Y
 * @param[out] Z Output block vector
 * @param[in] LDZ Leading dimension of Z
 */
template <typename T>
void default_shift_op(int32_t N, int32_t K, T ALPHA, const T* X, int32_t LDX,
                      T BETA, const T* Y, int32_t LDY, T* Z, int32_t LDZ) {
  laxpby(N, K, ALPHA, X, LDX, BETA, Y, LDY, Z, LDZ);
}

}  // namespace detail

/// A class organizing GMRES solver settings
struct gmres_settings {
  int32_t max_krylov_dim =
      20;  ///< Maximum dimension of the Krylov subspace before restart
  int32_t max_restart = 5;   ///< Maximum number of restarts in the GMRES solver
  bool do_sync_spmv = true;  ///< Synchronize SPMV for each vector as opposed to
                             ///< individual invocations for each vector
  int32_t verbosity = -1;    ///< Print control
  double tol = 1e-6;         ///< Residual convergence tolerance
};

/// GMRES convergence exception
struct gmres_did_not_converge_exception : public std::exception {
  const char* what() const throw() {
    return "GMRES Did Not Converge with Specified Settings";
  }
};

/**
 *  @brief Apply a series of Given's rotations as generated by the GMRES
 *  procedure and generate a new rotation to reduce the next Hessenberg
 *  matrix.
 *
 *  @tparam T Field type of the underlying matrix data
 *
 *  @param[in]     K  Current dimension of the Krylov Subspace
 *  @param[in/out] H  Current column of the Hessenberg matrix: Dimension(K+1)
 *                    On exit: the reduced column of the Hessenberg matrix by
 * the next Given's rotation
 *  @param[in]     C  Cosines of the previous Given's rotations: Dimension(K-1)
 *  @param[in]     S  Sines of the previous Given's rotations:   Dimension(K-1)
 *
 *  @returns (Cn,Sn) describing the next Given's rotation
 */
template <typename T>
auto gmres_apply_givens_rotation(int32_t K, T* H, const T* C, const T* S) {
  // Apply previous rotations
  // [ C        S ] [ H(i)   ] = [ C*H(i)   + S*H(i+1)     ]
  // [ -conj(S) C ] [ H(i+1) ]   [ C*H(i+1) - conj(S)*H(i) ]
  for (int32_t i = 0; i < (K - 1); ++i) {
    const auto tmp = C[i] * H[i] + S[i] * H[i + 1];
    H[i + 1] = C[i] * H[i + 1] - detail::smart_conj(S[i]) * H[i];
    H[i] = tmp;
  }

  // Generate next rotation and decimate subdiagonal of H
  // [ Cn        Sn ] [ H(K-1) ] = [ Cn*H(K-1) + Sn*H(K) ]
  // [ -conj(Sn) Cn ] [ H(K)   ]   [ 0                   ]
  auto [Cn, Sn] = rotg(H[K - 1], H[K]);

  H[K - 1] = Cn * H[K - 1] + Sn * H[K];
  H[K] = 0;

  return std::pair(Cn, Sn);
}

/**
 *  @brief Simultaneously compute the residuals and residual norms for current
 *  approximations of linear system solutions for multiple shifts and right
 *  hand sides.
 *
 *  @tparam T Field type of the underlying matrix data
 *
 *  @param[in]     N       Problem dimension
 *  @param[in]     NRHS    Number of right hand sides
 *  @param[in]     NS      Number of shifts
 *  @param[in]     A       Functor to apply the system matrix
 *  @param[in]     shifts  Shifts: Dimension (NS)
 *  @param[in]     B       Right hand side: Dimension (LDB,NRHS,NS)
 *  @param[in]     LDB     Leading dimension of B
 *  @param[in]     X       Approximate solution vectors: Dimension (LDB,NRHS,NS)
 *  @param[in]     LDX     Leading dimension of X
 *  @param[out]    R       Residuals: Dimension (LDR, NRHS, NS)
 *  @param[in]     LDR     Leading dimension of R
 *
 *  @returns Residual norms
 */
template <typename T>
auto sync_residuals(int32_t N, int32_t NRHS, int32_t NS,
                    const matrix_op_t<T>& A, const shift_op_t<T>& Sop,
                    const T* shifts, const T* B, int32_t LDB, const T* X,
                    int32_t LDX, T* R, int32_t LDR) {
  assert(LDB >= N);
  assert(LDX >= N);
  assert(LDR >= N);

  const int32_t NLS = NRHS * NS;

  // R(S) = B - (A - S*I)*X(S) = B + S*X(S) - A*X(S)
  for (int32_t iS = 0; iS < NS; ++iS) {
    auto* Rs = R + iS * NRHS * LDR;
    auto* Xs = X + iS * NRHS * LDX;

    // R(S) = B + S * X(S)
    Sop(N, NRHS, shifts[iS], Xs, LDX, T(1.), B, LDB, Rs, LDR);
  }

  // R(S) = R(S) - A * X(S)
  A(N, NLS, T(-1.), X, LDX, T(1.), R, LDR);

  // Compute Residual Norms
  std::vector<detail::real_t<T>> res_norms(NLS);
  for (int32_t k = 0; k < NLS; ++k) res_norms[k] = two_norm(N, R + k * LDR, 1);

  return res_norms;
}

/**
 *  @brief Performs the Arnoldi step required for GMRES-Arnoldi.
 *
 *  Appends a Krylov vector and updates the Hessenberg matrix. Each Matrix
 *  vector product is performed in sequence using Level-2 BLAS or similar.
 *
 *  @tparam T Field type of the underlying matrix data
 *
 *  @param[in]     N         Problem dimension
 *  @param[in]     NRHS      Number of right hand sides
 *  @param[in]     NS        Number of shifts
 *  @param[in]     K         Current dimension of the Krylov Subspace
 *  @param[in]     A         Functor to apply the system matrix
 *  @param[in]     S         Shifts: Dimension (NS)
 *  @param[in/out] Q         Krylov subspace: Dimension( LDQ_LOCAL, K+1, NRHS,
 * NS )
 *  @param[in]     LDQ       Distance between Q's for different linear systems
 *  @param[in]     LDQ_LOCAL Leading dimension of Q for a particular linear
 * system
 *  @param[in/out] R         Hessenberg matrix: Dimension( LDH_LOCAL, K, NRHS,
 * NS )
 *  @param[in]     LDR       Distance between H's for different linear systems
 *  @param[in]     LDR_LOCAL Leading dimension of H for a particular linear
 * system
 *
 */

template <typename T>
void gmres_arnoldi_nosync(int32_t N, int32_t NRHS, int32_t NS, int32_t K,
                          const matrix_op_t<T>& A,
                          const shifted_precond_op_t<T>& Minv,
                          const shift_op_t<T>& Sop, const T* S, T* Q,
                          int32_t LDQ, int32_t LDQ_LOCAL, T* Z, int32_t LDZ,
                          int32_t LDZ_LOCAL, T* H, int32_t LDH,
                          int32_t LDH_LOCAL) {
  const int32_t NLS = NRHS * NS;

  for (int32_t iLS = 0; iLS < NLS; ++iLS) {
    auto* QLS = Q + iLS * LDQ;
    auto* ZLS = Z + iLS * LDZ;
    auto* HLS = H + iLS * LDH;

    auto* Qk = QLS + K * LDQ_LOCAL;
    auto* Qkp1 = Qk + LDQ_LOCAL;
    auto* Zk = ZLS + K * LDZ_LOCAL;
    auto* Zkp1 = Zk + LDZ_LOCAL;
    auto* Hk = HLS + K * LDH_LOCAL;

    const auto shift = S[iLS / NRHS];

    if (Minv) {
      // Q(:,K+1) = (A - S*I) * M(S) * Q(:,K)

      // Z(:,K) = Q(:,K)
      lacpy(N, 1, Qk, LDQ, Zk, LDZ);

      // Z(:,K) = M(S) * Z(:,K)
      Minv(N, 1, shift, Zk, LDZ);

      // Q(:,K+1) = S * Z(:,K)
      // lascal( N, 1, shift, Zk, LDZ, Qkp1, LDQ );
      Sop(N, 1, shift, Zk, LDZ, T(0.), Qkp1, LDQ, Qkp1, LDQ);

      // Q(:,K+1) = A * Z(:,K) - Q(:,K+1)
      A(N, 1, T(1.), Zk, LDZ, T(-1.), Qkp1, LDQ);

    } else {
      // Q(:,K+1) = (A - S*I) * Q(:,K)
      // lascal( N, 1, shift, Qk, LDQ, Qkp1, LDQ );
      Sop(N, 1, shift, Qk, LDQ, T(0.), Qkp1, LDQ, Qkp1, LDQ);
      A(N, 1, T(1.), Qk, LDQ, T(-1.), Qkp1, LDQ);
    }

    arnoldi_iter(N, K + 1, QLS, LDQ_LOCAL, Qkp1, Hk);
  }
}

/**
 *  @brief Performs the Arnoldi step required for GMRES-Arnoldi.
 *
 *  Appends a Krylov vector and updates the Hessenberg matrix. All matrix-
 *  vector products are performed simultaneously using Level-3 BLAS or similar
 *
 *  @tparam T Field type of the underlying matrix data
 *
 *  @param[in]     N         Problem dimension
 *  @param[in]     NRHS      Number of right hand sides
 *  @param[in]     NS        Number of shifts
 *  @param[in]     K         Current dimension of the Krylov Subspace
 *  @param[in]     A         Functor to apply the system matrix
 *  @param[in]     S         Shifts: Dimension (NS)
 *  @param[in/out] Q         Krylov subspace: Dimension( LDQ_LOCAL, K+1, NRHS,
 * NS )
 *  @param[in]     LDQ       Distance between Q's for different linear systems
 *  @param[in]     LDQ_LOCAL Leading dimension of Q for a particular linear
 * system
 *  @param[in/out] R         Hessenberg matrix: Dimension( LDH_LOCAL, K, NRHS,
 * NS )
 *  @param[in]     LDR       Distance between H's for different linear systems
 *  @param[in]     LDR_LOCAL Leading dimension of H for a particular linear
 * system
 *
 */
template <typename T>
void gmres_arnoldi_sync(int32_t N, int32_t NRHS, int32_t NS, int32_t K,
                        const matrix_op_t<T>& A,
                        const shifted_precond_op_t<T>& Minv,
                        const shift_op_t<T>& Sop, const T* S, T* Q, int32_t LDQ,
                        int32_t LDQ_LOCAL, T* Z, int32_t LDZ, int32_t LDZ_LOCAL,
                        T* H, int32_t LDH, int32_t LDH_LOCAL) {
  const int32_t NLS = NRHS * NS;

  auto* Qk = Q + K * LDQ_LOCAL;
  auto* Qkp1 = Q + (K + 1) * LDQ_LOCAL;
  auto* Zk = Z + K * LDZ_LOCAL;
  auto* Zkp1 = Z + (K + 1) * LDZ_LOCAL;

  if (Minv) {
    // Q(:,K+1) = (A - S*I) * M(S) * Q(:,K)

    // Z(:,K) = Q(:,K)
    lacpy(N, NLS, Qk, LDQ, Zk, LDZ);

    for (int32_t iS = 0; iS < NS; ++iS) {
      auto* Zs = Zk + iS * NRHS * LDZ;
      auto* Qs = Qkp1 + iS * NRHS * LDQ;

      // Z(:,K) = M(S) * Z(:,K)
      Minv(N, NRHS, S[iS], Zs, LDZ);

      // Q(:,K+1) = S * Z(:,K)
      // lascal( N, NRHS, S[iS], Zs, LDZ, Qs, LDQ );
      Sop(N, NRHS, S[iS], Zs, LDZ, T(0.), Qs, LDQ, Qs, LDQ);
    }

    // Q(:,K+1) = A * Z(:,K) - Q(:,K+1)
    A(N, NLS, T(1.), Zk, LDZ, T(-1.), Qkp1, LDQ);

  } else {
    // Q(:, K+1) = (A - S*I) * Q(:, K)

    // Q(:, K+1) = S * Q(:, K)
    for (int32_t iS = 0; iS < NS; ++iS)
      // lascal( N, NRHS, S[iS], Qk + iS*NRHS*LDQ, LDQ, Qkp1 + iS*NRHS*LDQ, LDQ
      // );
      Sop(N, NRHS, S[iS], Qk + iS * NRHS * LDQ, LDQ, T(0.),
          Qkp1 + iS * NRHS * LDQ, LDQ, Qkp1 + iS * NRHS * LDQ, LDQ);

    // Synchronize the application of A into all linear systems
    // Q(:, K+1) = A * Q(:, K) - Q(:, K+1)
    A(N, NLS, T(1.), Qk, LDQ, T(-1.), Qkp1, LDQ);
  }

  for (int32_t k = 0; k < NLS; ++k) {
    auto* Qk = Q + k * LDQ;
    auto* Hk = H + k * LDH;

    auto* Qmp1 = Qk + (K + 1) * LDQ_LOCAL;
    auto* Hm = Hk + K * LDH_LOCAL;

    arnoldi_iter(N, K + 1, Qk, LDQ_LOCAL, Qmp1, Hm);
  }
}

/**
 * @brief Reconstruct solutions for several linear systems (LS)
 * from contiguous GMRES krylov subspaces
 *
 * @param[in] N Problem dimension
 * @param[in] K Krylov subspace dimension
 * @param[in] NLS Number of linear systems being solved
 * @param[in] Q The Krylov subspace for all linear systems
 * @param[in] LDQ Offset between LS blocks
 * @param[in] LDQ_LOCAL Leading dimension for Q within an LD block
 * @param[in] H Projected system matrix for all LS Krylov subspaces
 * @param[in] LDH Offset between LS blocks
 * @param[in] LDH_LOCAL Leading dimension for H within an LD block
 * @param[in] BETA Projected RHS for each LS
 * @param[in] LDBETA Leading dimension for BETA
 * @param[out] X Linear system solutions
 * @param[in]  Leading dimension for X
 */
template <typename T>
void gmres_form_solutions(int32_t N, int32_t K, int32_t NLS, const T* Q,
                          int32_t LDQ, int32_t LDQ_LOCAL, const T* H,
                          int32_t LDH, int32_t LDH_LOCAL, const T* BETA,
                          int32_t LDBETA, T* X, int32_t LDX) {
  std::vector<T> H_cpy(K * K);
  std::vector<T> coeffs(K);

  for (int32_t iLS = 0; iLS < NLS; ++iLS) {
    auto* HLS = H + iLS * LDH;
    auto* QLS = Q + iLS * LDQ;
    auto* CLS = BETA + iLS * LDBETA;
    auto* XLS = X + iLS * LDX;

    lacpy(K, K, HLS, LDH_LOCAL, H_cpy.data(), K);
    lacpy(K, 1, CLS, K, coeffs.data(), K);

    gesv(K, 1, H_cpy.data(), K, coeffs.data(), K);

    blas::gemm(blas::Layout::ColMajor, blas::Op::NoTrans, blas::Op::NoTrans, N,
               1, K, T(1.), QLS, LDQ_LOCAL, coeffs.data(), K, T(1.), XLS, LDX);
  }
}

/**
 *  @brief GMRES via Arnoldi Iteration
 *
 *  @param[in]     N       Problem dimension
 *  @param[in]     NRHS    Number of right hand sides
 *  @param[in]     NS      Number of shifts
 *  @param[in]     MAX_M   Maximum dimension of Krylov subspace
 *  @param[in]     A       Functor to apply the system matrix
 *  @param[in]     shifts  Shifts: Dimension (NS)
 *  @param[in]     B       Right hand side: Dimension (LDB,NRHS,NS)
 *  @param[in]     LDB     Leading dimension of B
 *  @param[in/out] X       Solution vectors: Dimension (LDX,NRHS,NS)
 *                         On input:  Initial guess
 *                         On output: Approximate solution vectors
 *  @param[in]     LDX     Leading dimension of X
 *  @param[in]     tol     GMRES convergence tolerance
 */
template <typename T>
void arnoldi_gmres(int32_t N, int32_t NRHS, int32_t NS, const matrix_op_t<T>& A,
                   const shifted_precond_op_t<T>& Minv,
                   const shift_op_t<T>& Sop, const T* shifts, const T* B,
                   int32_t LDB, T* X, int32_t LDX, gmres_settings settings) {
  const int32_t NLS = NRHS * NS;
  const int32_t MAX_M = settings.max_krylov_dim;

  assert(LDB >= N);
  assert(LDX >= N);

  // R is of dimension (LDR, NRHS, NS )
  int32_t LDR = N;
  std::vector<T> R(LDR * NLS);

  std::vector<detail::real_t<T>> rhs_norms(NRHS);

  if (settings.verbosity > 1) {
    QDK_LOGGER().info("GMRES Received {} Shifts:", NS);
    for (int32_t iS = 0; iS < NS; ++iS)
      QDK_LOGGER().info("  {:>5}: {:>16}", iS, shifts[iS]);
  }

  auto print_residuals = [&](const auto& res) {
    QDK_LOGGER().info("{:>5} {:>22} {:>22}", "LS", "Residual",
                      "Relative Residual");
    for (int32_t k = 0; k < NLS; ++k)
      QDK_LOGGER().info("{:>5} {:>22} {:>22}", k, res[k],
                        res[k] / rhs_norms[k % NRHS]);
  };

  // Compute RHS norms
  for (int32_t k = 0; k < NRHS; ++k) rhs_norms[k] = two_norm(N, B + k * LDB, 1);

  if (settings.verbosity > 1) {
    QDK_LOGGER().info("GMRES Received {} Right Hand Sides with Norms:", NRHS);
    for (int32_t iRHS = 0; iRHS < NRHS; ++iRHS)
      QDK_LOGGER().info("  {:>5}: {:>16}", iRHS, rhs_norms[iRHS]);
  }

  // Form residual R(S) = B - (A - S*I)X(S) = B + S*X(S) - AX(S)
  auto res_norms = sync_residuals(N, NRHS, NS, A, Sop, shifts, B, LDB, X, LDX,
                                  R.data(), LDR);

  if (settings.verbosity > 1) {
    QDK_LOGGER().info("Initial Residual Norms");
    print_residuals(res_norms);
  }

  auto rel_res_norms = res_norms;
  for (auto iLS = 0; iLS < NLS; ++iLS)
    rel_res_norms[iLS] /= rhs_norms[iLS % NRHS];

  // Allocate intermediates
  // Q    : (LDQ_LOCAL, MAX_M+1, NRHS, NS) == (LDQ,    NRHS, NS) == (LDQ, NLS)
  // Z    : (LDZ_LOCAL, MAX_M+1, NRHS, NS) == (LDZ,    NRHS, NS) == (LDZ, NLS)
  // H    : (LDH_LOCAL, MAX_M,   NRHS, NS) == (LDH,    NRHS, NS) == (LDH, NLS)
  // BETA :                                   (LDBETA, NRHS, NS) == (LDBETA,
  // NLS) CN   :                                   (LDCN,   NRHS, NS) == (LDCN,
  // NLS) SN   :                                   (LDSN,   NRHS, NS) == (LDSN,
  // NLS)

  int32_t LDQ_LOCAL = N;
  int32_t LDZ_LOCAL = Minv ? N : 0;
  int32_t LDH_LOCAL = MAX_M + 1;

  int32_t LDQ = LDQ_LOCAL * (MAX_M + 1);
  int32_t LDZ = LDZ_LOCAL * (MAX_M + 1);
  int32_t LDH = LDH_LOCAL * MAX_M;
  int32_t LDBETA = MAX_M + 1;
  int32_t LDCN = MAX_M;
  int32_t LDSN = MAX_M;

  int32_t LDY = Minv ? N : 0;

  std::vector<T> Q(LDQ * NLS), Z(LDZ * NLS), H(LDH * NLS), betas(LDBETA * NLS),
      CN(LDCN * NLS), SN(LDSN * NLS),
      Y(LDY * NLS);  // Temp solution storage in the case of preconditioning

  // Convergence Lambda
  auto below_tol = [&](const auto& x) { return x < settings.tol; };

  // Convenience Lambdas
  auto form_solutions = [&](int32_t K, T* X_use, int32_t LDX_use) {
    auto* basis_use = bool(Minv) ? Z.data() : Q.data();
    auto ld_basis = bool(Minv) ? LDZ : LDQ;
    auto ld_local_basis = bool(Minv) ? LDZ_LOCAL : LDQ_LOCAL;

    gmres_form_solutions(N, K, NLS, basis_use, ld_basis, ld_local_basis,
                         H.data(), LDH, LDH_LOCAL, betas.data(), LDBETA, X_use,
                         LDX_use);
  };

  // Outer GMRES Iterations
  int32_t gmres_outer_it = 0;
  int32_t gmres_inner_it = 0;
  auto max_restart = settings.max_restart;
  for (gmres_outer_it = 0; gmres_outer_it < max_restart; ++gmres_outer_it) {
    // Compute Initial Qs and beta
    // Loops over combined NRHS/NS index
    for (int32_t k = 0; k < NLS; ++k) {
      // Q(:,0,k) = R(:,k) / ||R(:,k)||
      lascal(N, 1, T(1.) / res_norms[k], R.data() + k * LDR, LDR,
             Q.data() + k * LDQ, LDQ);

      // BETA(:,k) = ||R(:,k)|| * e1
      betas[k * (MAX_M + 1)] = res_norms[k];
    }

    if (settings.verbosity > 2) {
      QDK_LOGGER().info("GMRES Iterations:");
      QDK_LOGGER().info("{:>5} {:>5} {:>18}", "It", "LS", "Error Estimate");
    }

    // GMRES Inner Iterations
    int32_t krylov_m;
    for (krylov_m = 0; krylov_m < MAX_M; ++krylov_m) {
      if (settings.do_sync_spmv)
        gmres_arnoldi_sync(N, NRHS, NS, krylov_m, A, Minv, Sop, shifts,
                           Q.data(), LDQ, LDQ_LOCAL, Z.data(), LDZ, LDZ_LOCAL,
                           H.data(), LDH, LDH_LOCAL);
      else
        gmres_arnoldi_nosync(N, NRHS, NS, krylov_m, A, Minv, Sop, shifts,
                             Q.data(), LDQ, LDQ_LOCAL, Z.data(), LDZ, LDZ_LOCAL,
                             H.data(), LDH, LDH_LOCAL);

      std::vector<detail::real_t<T>> est_err(NLS);
      for (int32_t k = 0; k < NLS; ++k) {
        auto* Hk = H.data() + k * LDH;
        auto* CNk = CN.data() + k * MAX_M;
        auto* SNk = SN.data() + k * MAX_M;
        auto* betak = betas.data() + k * (MAX_M + 1);

        auto* Hm = Hk + krylov_m * LDH_LOCAL;

        auto [cn, sn] = gmres_apply_givens_rotation(krylov_m + 1, Hm, CNk, SNk);

        CNk[krylov_m] = cn;
        SNk[krylov_m] = sn;

        // Update Error vectors
        // [ C        S ] [ B ] = [ C*B        ]
        // [ -conj(S) C ] [ 0 ]   [ -conj(S)*B ]
        betak[krylov_m + 1] = -detail::smart_conj(sn) * betak[krylov_m];
        betak[krylov_m] = cn * betak[krylov_m];

        // Error estimate
        est_err[k] = std::abs(betak[krylov_m + 1]) / rhs_norms[k % NRHS];
      }

      if (settings.verbosity > 2) {
        for (int32_t k = 0; k < NLS; ++k) {
          QDK_LOGGER().info("{:>5} {:>5} {:>18}", krylov_m, k, est_err[k]);
        }
      }

      // Check initial convergence, based on preconditioned system, does not
      // necessacarily indicate true convergence
      bool all_conv = std::all_of(est_err.begin(), est_err.end(), below_tol);

      if (all_conv) {
        bool true_all_conv = true;

        // No extra checks are needed if no preconditioner
        if (Minv) {
          // Form solution in temp storage
          lacpy(N, NLS, X, LDX, Y.data(), LDY);
          form_solutions(krylov_m + 1, Y.data(), LDY);

          // Check true residuals
          auto rnorms = sync_residuals(N, NRHS, NS, A, Sop, shifts, B, LDB,
                                       Y.data(), LDY, R.data(), LDR);

          auto rel_rnorms = rnorms;
          for (auto iLS = 0; iLS < NLS; ++iLS)
            rel_rnorms[iLS] /= rhs_norms[iLS % NRHS];

          true_all_conv =
              std::all_of(rel_rnorms.begin(), rel_rnorms.end(), below_tol);
        }

        if (true_all_conv) {
          krylov_m++;
          break;
        }
      }

    }  // GMRES Inner Iterations

    gmres_inner_it += krylov_m;  // Increment inner iterations

    // Construct Approximate Solutions
    form_solutions(krylov_m, X, LDX);

    // Compute true residual
    res_norms = sync_residuals(N, NRHS, NS, A, Sop, shifts, B, LDB, X, LDX,
                               R.data(), LDR);
    rel_res_norms = res_norms;
    for (auto iLS = 0; iLS < NLS; ++iLS)
      rel_res_norms[iLS] /= rhs_norms[iLS % NRHS];

    // Check for true convergence
    bool all_conv =
        std::all_of(rel_res_norms.begin(), rel_res_norms.end(), below_tol);

    if (all_conv) {
      gmres_outer_it++;
      break;
    } else {
    }

  }  // Outer GMRES Iterations

  // Check for convergence once again...
  bool all_conv =
      std::all_of(rel_res_norms.begin(), rel_res_norms.end(), below_tol);

  if (gmres_outer_it == max_restart and not all_conv) {
    throw gmres_did_not_converge_exception();
  }

  if (settings.verbosity >= 0) {
    QDK_LOGGER().info("GMRES Converged in {} inner iterations and {} restarts",
                      gmres_inner_it, gmres_outer_it - 1);
    if (settings.verbosity > 0) {
      QDK_LOGGER().info("GMRES Results:");
      print_residuals(res_norms);
    }
  }
}

template <typename T>
void arnoldi_gmres(int32_t N, int32_t NRHS, int32_t NS, const matrix_op_t<T>& A,
                   const T* shifts, const T* B, int32_t LDB, T* X, int32_t LDX,
                   gmres_settings settings) {
  shift_op_t<T> Sop = detail::default_shift_op<T>;
  shifted_precond_op_t<T> Mop = shifted_precond_op_t<T>();

  arnoldi_gmres(N, NRHS, NS, A, Mop, Sop, shifts, B, LDB, X, LDX, settings);
}

template <typename T>
void arnoldi_gmres(int32_t N, int32_t NRHS, int32_t NS, const matrix_op_t<T>& A,
                   const shifted_precond_op_t<T> Mop, const T* shifts,
                   const T* B, int32_t LDB, T* X, int32_t LDX,
                   gmres_settings settings) {
  shift_op_t<T> Sop = detail::default_shift_op<T>;

  arnoldi_gmres(N, NRHS, NS, A, Mop, Sop, shifts, B, LDB, X, LDX, settings);
}

template <typename T>
void arnoldi_gmres(int32_t N, int32_t NRHS, int32_t NS, const matrix_op_t<T>& A,
                   const shift_op_t<T>& Sop, const T* shifts, const T* B,
                   int32_t LDB, T* X, int32_t LDX, gmres_settings settings) {
  shifted_precond_op_t<T> Mop = shifted_precond_op_t<T>();

  arnoldi_gmres(N, NRHS, NS, A, Mop, Sop, shifts, B, LDB, X, LDX, settings);
}
}  // namespace qdk::chemistry::scf
