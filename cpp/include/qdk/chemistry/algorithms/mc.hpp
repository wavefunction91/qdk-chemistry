// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See LICENSE.txt in the project root for
// license information.

#pragma once
#include <functional>
#include <iostream>
#include <qdk/chemistry/algorithms/algorithm.hpp>
#include <qdk/chemistry/data/hamiltonian.hpp>
#include <qdk/chemistry/data/settings.hpp>
#include <qdk/chemistry/data/wavefunction.hpp>

namespace qdk::chemistry::algorithms {

/**
 * @class MultiConfigurationSettings
 * @brief Settings class specific to multi-configurational calculations
 *
 * This class extends the base Settings class with parameters specific to
 * multi-configurational calculations. It provides default values for commonly
 * used settings in MC calculations such as reduced density matrix generation
 * and convergence thresholds.
 *
 * @see data::Settings
 */
class MultiConfigurationSettings : public data::Settings {
 public:
  /**
   * @brief Default constructor
   *
   * Creates a multi-configurational settings object with default parameter
   * values.
   */
  MultiConfigurationSettings() {
    // Initialize with default settings for MC calculations
    // evaluate 1 RDM
    set_default<bool>("calculate_one_rdm", false);
    // evaluate 2 RDM
    set_default<bool>("calculate_two_rdm", false);
    // energy convergence threshold
    set_default<double>("ci_residual_tolerance", 1.0e-6);
    // maximum number of iterations any Davidson
    set_default<size_t>("davidson_iterations", 200);
    // number of states
    set_default<size_t>("num_roots", 1);
  }

  /**
   * @brief Virtual destructor
   */
  virtual ~MultiConfigurationSettings() = default;
};

/**
 * @class MultiConfigurationCalculator
 * @brief Abstract base class for multi-configurational calculations in
 * quantum chemistry
 *
 * This class provides the interface for multi-configurational-based quantum
 * chemistry calculations. It serves as a base for various
 * multi-configurational methods, such as Complete Active Space CI (CAS-CI),
 * and other multi-reference quantum mechanical algorithms.
 *
 * The calculator takes a Hamiltonian as input and returns both the calculated
 * energy and the corresponding multi-configurational wavefunction.
 *
 * @see data::Hamiltonian
 * @see data::Wavefunction
 * @see data::Settings
 */
class MultiConfigurationCalculator
    : public Algorithm<MultiConfigurationCalculator,
                       std::pair<double, std::shared_ptr<data::Wavefunction>>,
                       std::shared_ptr<data::Hamiltonian>, unsigned int,
                       unsigned int> {
 public:
  /**
   * @brief Default constructor
   *
   * Creates a multi-configurational calculator with default settings.
   */
  MultiConfigurationCalculator() = default;

  /**
   * @brief Virtual destructor
   *
   * Ensures proper cleanup of derived classes.
   */
  virtual ~MultiConfigurationCalculator() = default;

  /**
   * @brief Perform multi-configurational calculation
   *
   * This method is auto-generated by the Algorithm base class and
   * automatically locks settings before execution, then delegates to
   * _run_impl().
   *
   * \cond DOXYGEN_SUPRESS (Doxygen warning suppression for argument packs)
   * @param hamiltonian The Hamiltonian operator describing the quantum system
   * @param n_active_alpha_electrons The number of alpha electrons in the
   * active space, inactive orbitals are assumed to be fully occupied.
   * @param n_active_beta_electrons The number of beta electrons in the
   * active space, inactive orbitals are assumed to be fully occupied.
   * \endcond
   *
   * @return A pair containing the calculated energy (first) and the resulting
   *         multi-configurational wavefunction (second)
   *
   * @throw std::runtime_error if the calculation fails
   * @throw std::invalid_argument if hamiltonian is invalid
   * @throw SettingsAreLocked if attempting to modify settings after run() is
   * called
   *
   * @note Settings are automatically locked when this method is called and
   * cannot be modified during or after execution.
   *
   * @see data::Hamiltonian
   * @see data::Wavefunction
   */
  using Algorithm::run;

  /**
   * @brief Access the algorithm's name
   *
   * @return The algorithm's name
   */
  virtual std::string name() const = 0;

  /**
   * @brief Access the algorithm's type name
   *
   * @return The algorithm's type name
   */
  std::string type_name() const final {
    return "multi_configuration_calculator";
  };

 protected:
  /**
   * @brief Implementation of multi-configurational calculation
   *
   * This method contains the actual calculation logic. It is automatically
   * called by run() after settings have been locked.
   *
   * @param hamiltonian The Hamiltonian operator
   * @param n_active_alpha_electrons Number of alpha electrons in active
   * space
   * @param n_active_beta_electrons Number of beta electrons in active
   * space
   * @return A pair containing the energy and wavefunction
   */
  virtual std::pair<double, std::shared_ptr<data::Wavefunction>> _run_impl(
      std::shared_ptr<data::Hamiltonian> hamiltonian,
      unsigned int n_active_alpha_electrons,
      unsigned int n_active_beta_electrons) const = 0;
};

/**
 * @brief Factory class for creating multi-configurational calculator
 * instances.
 *
 * The MultiConfigurationCalculatorFactory implements the Factory design
 * pattern to dynamically create and manage different implementations of
 * multi-configurational calculators. This allows the library to support
 * multiple MC calculation methods while providing a unified interface for
 * clients.
 *
 * The factory maintains a registry of calculator implementations identified
 * by string keys. New implementations can be registered at runtime using the
 * register_builder method, and instances can be created using the create
 * method.
 *
 * Typical usage:
 * ```
 * // Register a custom implementation
 * MultiConfigurationCalculatorFactory::register_instance("my_method", []() {
 *     return std::make_unique<MyMultiConfigurationCalculator>();
 * });
 *
 * // Create an instance
 * auto calculator = MultiConfigurationCalculatorFactory::create("my_method");
 *
 * // Get available implementations
 * auto available = MultiConfigurationCalculatorFactory::available();
 * ```
 *
 * @see MultiConfigurationCalculator for the interface implemented by concrete
 * calculators
 */
struct MultiConfigurationCalculatorFactory
    : public AlgorithmFactory<MultiConfigurationCalculator,
                              MultiConfigurationCalculatorFactory> {
  static std::string algorithm_type_name() {
    return "multi_configuration_calculator";
  }
  static void register_default_instances();
  static std::string default_algorithm_name() { return "macis_cas"; }
};

}  // namespace qdk::chemistry::algorithms
