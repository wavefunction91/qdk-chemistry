# Coverage pipeline for QDK/Chemistry

trigger:
  branches:
    include:
    - '*'

# Trigger this pipeline on PRs targeting any branch
pr:
  branches:
    include:
    - '*'
  drafts: true

parameters:
- name: march
  displayName: Micro Architecture
  default: native
  type: string
  values:
  - znver2
  - znver3
  - skylake-avx512
  - x86-64-v3
  - native

resources:
  repositories:
  - repository: self
    path: qdk-chemistry

variables:
- group: QdkChemistry
- name: date
  value: $[format('{0:yyyy}.{0:MM}.{0:dd}', pipeline.startTime)]
- name: march
  ${{ if eq(parameters.march, 'x86-64-v3') }}:
    value: x86-64
  ${{ else }}:
    value: ${{ parameters.march }}

stages:
- stage: Coverage
  displayName: Coverage
  jobs:
  - job: Coverage
    displayName: Coverage
    pool: $(CPU_POOL_X86)
    timeoutInMinutes: 240
    variables:
      LD_LIBRARY_PATH: $LD_LIBRARY_PATH:/usr/local/lib
    steps:
    - task: UsePythonVersion@0
      inputs:
        versionSpec: '3.13'
      displayName: Use Python 3.13

    - template: templates/non-docker-build.yml
      parameters:
        march: ${{ variables.march }}
        buildType: Debug
        enableCoverage: ON
        buildTesting: ON
        agentBuildDirectory: $(Agent.BuildDirectory)
        systemDefaultWorkingDirectory: $(System.DefaultWorkingDirectory)
        artifactProject: $(DEPENDENCIES_ARTIFACT_PROJECT)
        artifactFeed: $(DEPENDENCIES_ARTIFACT_FEED)

    # C++ Tests with Coverage
    - script: |
        mkdir -p $(System.DefaultWorkingDirectory)/test-results
        cd $(Agent.BuildDirectory)/qdk-chemistry/build_cpp/tests

        # Initialize test result tracking
        FAILED_TESTS=()
        TOTAL_TESTS=0
        PASSED_TESTS=0

        echo "=== Running C++ Tests ==="
        for test_exe in test_*; do
          if [ -x "$test_exe" ] && [ -f "$test_exe" ]; then
            TOTAL_TESTS=$((TOTAL_TESTS + 1))
            echo "Running $test_exe with XML output..."

            # Run test with timeout and capture exit code
            set +e
            timeout 300 ./"$test_exe" --gtest_output=xml:$(System.DefaultWorkingDirectory)/test-results/"$test_exe"_results.xml
            EXIT_CODE=$?
            set -e

            # Check for various failure conditions
            if [ $EXIT_CODE -ne 0 ]; then
              echo "ERROR: Test $test_exe failed with exit code $EXIT_CODE"

              # Check for specific error types
              case $EXIT_CODE in
                139)
                  echo "CRITICAL: Test $test_exe crashed with SEGFAULT (SIGSEGV)"
                  ;;
                134|6)
                  echo "CRITICAL: Test $test_exe crashed with SIGABRT (assertion failure or abort)"
                  ;;
                124)
                  echo "CRITICAL: Test $test_exe timed out after 300 seconds"
                  ;;
                *)
                  echo "CRITICAL: Test $test_exe failed with exit code $EXIT_CODE"
                  ;;
              esac

              FAILED_TESTS+=("$test_exe (exit code: $EXIT_CODE)")
            else
              echo "SUCCESS: Test $test_exe passed"
              PASSED_TESTS=$((PASSED_TESTS + 1))
            fi
            echo "----------------------------------------"
          fi
        done

        echo "=== C++ Test Summary ==="
        echo "Total tests: $TOTAL_TESTS"
        echo "Passed tests: $PASSED_TESTS"
        echo "Failed tests: ${#FAILED_TESTS[@]}"

        if [ ${#FAILED_TESTS[@]} -gt 0 ]; then
          echo "=== FAILED TESTS ==="
          for failed_test in "${FAILED_TESTS[@]}"; do
            echo "  - $failed_test"
          done
          echo "=== C++ TESTS FAILED - PIPELINE WILL FAIL ==="
        fi

        mkdir -p $(System.DefaultWorkingDirectory)/coverage-reports
        gcovr --root $(Agent.BuildDirectory)/qdk-chemistry/cpp --object-directory $(Agent.BuildDirectory)/qdk-chemistry/build_cpp --exclude '.*/tests/.*' --exclude '.*test.*\.cpp' --exclude '.*gtest.*' --exclude '.*gmock.*' --html-details $(System.DefaultWorkingDirectory)/coverage-reports/cpp_coverage.html --xml $(System.DefaultWorkingDirectory)/coverage-reports/cpp_coverage.xml --txt $(System.DefaultWorkingDirectory)/coverage-reports/cpp_coverage.txt
        echo "Coverage Summary:"
        cat $(System.DefaultWorkingDirectory)/coverage-reports/cpp_coverage.txt

        # Exit with failure if any tests failed
        if [ ${#FAILED_TESTS[@]} -gt 0 ]; then
          exit 1
        fi
      displayName: Run C++ Tests with XML Output

    # Python Tests with Coverage
    - script: |
        mkdir -p $(System.DefaultWorkingDirectory)/test-results
        cd $(Agent.BuildDirectory)/qdk-chemistry/python

        # The build directory will be something like build/cp313-cp313-linux_x86_64
        BUILD_TEMP=$(find . -type d -path "./build/cp*" | head -1)

        echo "Found build directory: $BUILD_TEMP"
        echo "$BUILD_TEMP" > build_temp_path.txt
        echo "Saved build temp path to file: $(cat build_temp_path.txt)"

        # Read BUILD_TEMP from the file written in the previous step
        if [ -f "build_temp_path.txt" ]; then
            BUILD_TEMP=$(cat build_temp_path.txt)
            echo "Read build temp directory from file: $BUILD_TEMP"
        else
            echo "Warning: build_temp_path.txt not found"
            BUILD_TEMP=""
        fi

        # Run coverage with explicit source specification
        echo "=== Running Coverage ==="
        echo "Coverage version: $(python3 -m coverage --version)"

        # Remove any existing coverage data
        rm -f .coverage*

        # Try using pytest-cov as alternative approach with proper error handling
        echo "Coverage with pytest-cov..."

        # Run pytest with explicit error handling
        set +e
        python3 -m pytest \
          --cov=qdk_chemistry \
          --cov-report=xml:$(System.DefaultWorkingDirectory)/coverage-reports/python_coverage.xml \
          --cov-report=html:$(System.DefaultWorkingDirectory)/coverage-reports/python_coverage_html \
          --cov-report=term \
          --junitxml=$(System.DefaultWorkingDirectory)/test-results/pytest_report.xml \
          -v \
          --tb=short \
          > $(System.DefaultWorkingDirectory)/coverage-reports/python_coverage.txt 2>&1

        PYTEST_EXIT_CODE=$?
        set -e

        # Display the output
        echo "=== Python Test Output ==="
        cat $(System.DefaultWorkingDirectory)/coverage-reports/python_coverage.txt
        echo "=========================="

        # Check pytest exit code and handle different failure types
        if [ $PYTEST_EXIT_CODE -ne 0 ]; then
          echo "ERROR: Python tests failed with exit code $PYTEST_EXIT_CODE"

          # Analyze exit codes (pytest exit codes)
          case $PYTEST_EXIT_CODE in
            1)
              echo "CRITICAL: Tests failed - some test failures occurred"
              ;;
            2)
              echo "CRITICAL: Tests were interrupted by the user"
              ;;
            3)
              echo "CRITICAL: Internal error occurred during test execution"
              ;;
            4)
              echo "CRITICAL: pytest command line usage error"
              ;;
            5)
              echo "CRITICAL: No tests were collected"
              ;;
            139)
              echo "CRITICAL: Python tests crashed with SEGFAULT"
              ;;
            134|6)
              echo "CRITICAL: Python tests crashed with SIGABRT"
              ;;
            *)
              echo "CRITICAL: Python tests failed with unknown exit code $PYTEST_EXIT_CODE"
              ;;
          esac

          # Check for segfaults or crashes in the output
          if grep -qi "segmentation fault\|segfault\|sigsegv" $(System.DefaultWorkingDirectory)/coverage-reports/python_coverage.txt; then
            echo "CRITICAL: Segmentation fault detected in Python test output"
          fi

          if grep -qi "fatal error\|abort\|assertion.*failed" $(System.DefaultWorkingDirectory)/coverage-reports/python_coverage.txt; then
            echo "CRITICAL: Fatal error or assertion failure detected in Python test output"
          fi

          echo "=== PYTHON TESTS FAILED - PIPELINE WILL FAIL ==="
        else
          echo "Python tests completed successfully!"
        fi

        # After tests run, copy .gcda files from temp directory if it still exists
        if [ -n "$BUILD_TEMP" ] && [ -d "$BUILD_TEMP" ]; then
            echo "=== Copying .gcda files from temp directory ==="
            find "$BUILD_TEMP" -name "*.gcda" -exec cp {} coverage_build/ \; 2>/dev/null || true
            echo "Copied .gcda files to coverage_build/"
        fi

        echo "Python Coverage Summary:"
        if [ -f "$(System.DefaultWorkingDirectory)/coverage-reports/python_coverage.txt" ]; then
          # Extract just the coverage summary to avoid too much output
          tail -20 $(System.DefaultWorkingDirectory)/coverage-reports/python_coverage.txt
        fi

        # Exit with failure if pytest failed
        if [ $PYTEST_EXIT_CODE -ne 0 ]; then
          exit 1
        fi
      displayName: Run Python Tests then Generate Python Coverage

    - script: |
        cd $(Agent.BuildDirectory)/qdk-chemistry/python

        echo "=== Looking for pybind11 coverage files ==="
        PYBIND_BUILD_DIR=$(find . -wholename "./build/cp*/CMakeFiles/_core.dir" | head -1)

        if [ -n "$PYBIND_BUILD_DIR" ]; then
            echo "Found pybind11 build directory: $PYBIND_BUILD_DIR"

            # Check for coverage files
            GCNO_COUNT=$(find "$PYBIND_BUILD_DIR" -name "*.gcno" | wc -l)
            GCDA_COUNT=$(find "$PYBIND_BUILD_DIR" -name "*.gcda" | wc -l)

            echo "Found $GCNO_COUNT .gcno files and $GCDA_COUNT .gcda files"

            if [ "$GCNO_COUNT" -gt 0 ]; then
                # Set paths for gcovr
                PYTHON_ROOT="$(Agent.BuildDirectory)/qdk-chemistry/python"
                CLEAN_BUILD_DIR="${PYBIND_BUILD_DIR#./}"
                OBJECT_DIR="$(Agent.BuildDirectory)/qdk-chemistry/python/${CLEAN_BUILD_DIR}"

                echo "=== Coverage Generation Settings ==="
                echo "Python root: $PYTHON_ROOT"
                echo "Object directory: $OBJECT_DIR"

                # Show some sample files for debugging
                echo "Sample coverage files:"
                find "$PYBIND_BUILD_DIR" -name "*.gcno" | head -3
                find "$PYBIND_BUILD_DIR" -name "*.gcda" | head -3

                # Generate coverage report
                gcovr \
                  --root "$PYTHON_ROOT" \
                  --object-directory "$OBJECT_DIR" \
                  --filter '.*src/pybind11.*' \
                  --filter '.*src/cpp.*' \
                  --exclude '.*test.*' \
                  --exclude '.*external.*' \
                  --gcov-ignore-errors=no_working_dir_found \
                  --gcov-ignore-errors=source_not_found \
                  --verbose \
                  --xml "$(System.DefaultWorkingDirectory)/coverage-reports/pybind11_coverage.xml" \
                  --txt "$(System.DefaultWorkingDirectory)/coverage-reports/pybind11_coverage.txt" \
                  --html-details "$(System.DefaultWorkingDirectory)/coverage-reports/pybind11_coverage.html"

                echo "Pybind11 Coverage Summary:"
                if [ -f "$(System.DefaultWorkingDirectory)/coverage-reports/pybind11_coverage.txt" ]; then
                  cat $(System.DefaultWorkingDirectory)/coverage-reports/pybind11_coverage.txt
                else
                  echo "Pybind11 coverage report not generated"
                fi
            else
                echo "ERROR: No .gcno files found - coverage was not enabled during build"
            fi
        else
            echo "ERROR: Could not find pybind11 build directory"
            echo "Available build directories:"
            find . -type d -name "build" -o -name "cp*" | head -5
        fi
      displayName: Generate Pybind11 C++ Coverage

    - task: PublishCodeCoverageResults@2
      inputs:
        summaryFileLocation: $(System.DefaultWorkingDirectory)/coverage-reports/*.xml
        pathToSources: $(System.DefaultWorkingDirectory)
      displayName: Publish Combined Coverage Reports

    - task: PublishTestResults@2
      inputs:
        testResultsFormat: JUnit
        testResultsFiles: $(System.DefaultWorkingDirectory)/test-results/*.xml
        testRunTitle: QDK/Chemistry Tests
        mergeTestResults: true
        failTaskOnFailedTests: true
      displayName: Publish Test Results

    # Documentation tasks
    - script: |
        cd $(Agent.BuildDirectory)/qdk-chemistry/python
        pip install .[docs,plugins] --verbose
        python3 -c "import qdk_chemistry; print('qdk_chemistry version:', qdk_chemistry.__version__)"
        sudo apt-get update && sudo apt-get install -y doxygen graphviz
      displayName: Install Documentation Dependencies

    - script: |
        cd $(Agent.BuildDirectory)/qdk-chemistry/docs
        make clean all
      displayName: Generate Sphinx Documentation

    - script: |
        cd $(Agent.BuildDirectory)/qdk-chemistry/docs/build

        # Validate that documentation was built successfully
        if [ ! -d "html" ]; then
          echo "ERROR: HTML directory not found"
          exit 1
        fi

        if [ ! -f "html/index.html" ]; then
          echo "ERROR: index.html not found"
          exit 1
        fi

        # Check for common documentation files
        echo "Documentation structure:"
        find html -name "*.html" | head -10

        # Check file sizes to ensure content was generated
        HTML_SIZE=$(du -sh html | cut -f1)
        echo "Documentation size: $HTML_SIZE"

        # Count HTML files
        HTML_COUNT=$(find html -name "*.html" | wc -l)
        echo "Number of HTML files: $HTML_COUNT"

        if [ "$HTML_COUNT" -lt 5 ]; then
          echo "WARNING: Very few HTML files generated ($HTML_COUNT), documentation may be incomplete"
        fi
      displayName: Validate Documentation Build

    - task: PublishBuildArtifacts@1
      inputs:
        pathtoPublish: $(Agent.BuildDirectory)/qdk-chemistry/docs/build/html
        artifactName: qdk-chemistry-documentation
        publishLocation: Container
      displayName: Publish Documentation as Artifact
      condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
